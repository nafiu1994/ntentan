<?php

namespace ntentan;

use ntentan\utils\Input;
use ntentan\panie\InjectionContainer;
use ntentan\panie\exceptions\ResolutionException;

class Router
{
    /**
     * The routing table. An array of regular expressions and associated
     * operations. If a particular request sent in through the URL matches a
     * regular expression in the table, the associated operations are executed.
     *
     * @var array
     */
    private static $routes = [];
    
    private static $dynamicRoutes = [];
    
    /**
     * Keeps track of the order in which routes were added to the routing table.
     * @var type 
     */
    private static $routeOrder = [];
    
    private static $tempVariables = [];

    /**
     * The route which is currently being executed. If the routing engine has
     * modified the requested route, this property would hold the value of the
     * new route.
     * @var string
     */
    private static $route;

    /**
     * Variables exposed through getVar()
     * @var type 
     */
    private static $routerVariables = [];

    /**
     * Invoke the router to load a given resource.
     * @param string $route
     * @throws exceptions\RouteNotAvailableException
     */
    public static function loadResource($route)
    {
        self::$route = $route;
        $defaultParameters = self::$routes['default']['parameters']['default'];
        $routeParameters = [];
        
        // Go through predefined routes till a match is found
        foreach(self::$routeOrder as $routeName) {
            $routeDesription = self::$routes[$routeName];
            $routeParameters = self::match($route, $routeDesription);
            if(!empty($routeParameters)) break;
        }
                
        if(self::loadController($routeParameters + self::$routes[$routeName]['parameters']['default'])) return;
        
        // Fallback on dynamic routes which are generated by callables if
        // static routes fail
        $routeParameters = [];
        if(empty($routeParameters)) {
            foreach(self::$dynamicRoutes as $routeName => $dynamicRoute) {
                $routeParameters = call_user_func($dynamicRoute['function'], $route);
                if(!empty($routeParameters)) break;
            }
        }            
        if(self::loadController($routeParameters + self::$dynamicRoutes[$routeName]['parameters']['default'])) return;
        
        // Throw an exception if we're still alive
        throw new exceptions\RouteNotAvailableException(
           $route == '' ? 'Default route' : $route
        );
    }
    
    private static function loadController($params = [])
    {
        $controller = $params['controller'];
        $action = $params['action'];
        
        // Try to get the classname based on router parameters
        $controllerClassName = InjectionContainer::singleton(controllers\interfaces\ClassResolverInterface::class)
            ->getControllerClassName($controller);
        
        // Try to resolve the classname 
        $resolvedControllerClass = InjectionContainer::getResolvedClassName($controllerClassName);
        
        if($resolvedControllerClass) {
            // use resolved class name
            $params['controller_path'] = $controller;
            $controllerInstance = InjectionContainer::resolve($controllerClassName);
        } else if(class_exists($controller)) {
            // use controller class
            $controllerInstance = InjectionContainer::resolve($controller);
        } else {
            // failed!
            return false;
        }
        self::$routerVariables += $params;
        $controllerInstance->executeControllerAction($action, $params);            
        return true;
    }
    
    private static function match($route, $description)
    {
        $parameters = [];
        if(preg_match("|{$description['regexp']}|i", $route, $matches)) {           
            
            foreach($matches as $key => $value) {
                if(!is_numeric($key)) {
                    $parameters[$key] = $value;
                }
            }
            
            if(isset($parameters['route'])) {
                $parameters += self::loadResource($parameters['route']);
            }
        }
        return $parameters;
    }

    public static function mapRoute($name, $pattern, $parameters = [])
    {
        if(is_callable($pattern)) {
            // allocate a dynamic route if pattern is callable
            self::$dynamicRoutes[$name] = [
                'name' => $name,
                'function' => $pattern,
                'parameters' => $parameters
            ];
        } else {
            // generate a PCRE regular expression from pattern
            self::$routeOrder[] = $name;
            self::$tempVariables = [];

            $regexp = preg_replace_callback(
                "/{(?<prefix>\*|#)?(?<name>[a-z_][a-zA_Z0-9\_]*)}/", 
                function($matches) {
                    self::$tempVariables[] = $matches['name'];
                        return sprintf(
                            "(?<{$matches['name']}>[a-z0-9_.~:#[\]@!$&'()*+,;=%s]+)?", 
                            $matches['prefix'] ? "\-/_" : null
                        );
                },
                str_replace('/', '(/)?', $pattern)
            );
            if(isset($parameters['default'])) {
                foreach($parameters['default'] as $parameter => $value) {
                    if(!in_array($parameter, self::$tempVariables)) self::$tempVariables[] = $parameter;
                }
            }

            self::$routes[$name] = [
                'pattern' => $pattern,
                'regexp' => $regexp,
                'parameters' => $parameters,
                'variables' => self::$tempVariables
            ];            
        }
    }

    public static function getVar($var)
    {
        if (isset(self::$routerVariables[$var])) {
            return self::$routerVariables[$var];
        }
        return null;
    }
    
    public static function getRoute()
    {
        return self::$route;
    }
    
    public static function getRouteDefinition($routeName)
    {
        return self::$routes[$routeName];
    }
}
