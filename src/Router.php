<?php

namespace ntentan;

use ntentan\utils\Input;
use ntentan\panie\InjectionContainer;
use ntentan\panie\exceptions\ResolutionException;

class Router
{
    /**
     * The routing table. An array of regular expressions and associated
     * operations. If a particular request sent in through the URL matches a
     * regular expression in the table, the associated operations are executed.
     *
     * @var array
     */
    private static $routes = [];
    
    private static $dynamicRoutes = [];
    private static $staticRoutes = [];
    
    private static $tempVariables = [];

    /**
     * The route which is currently being executed. If the routing engine has
     * modified the requested route, this property would hold the value of the
     * new route.
     * @var string
     */
    private static $route;

    /**
     * Variables exposed through getVar()
     * @var type 
     */
    private static $routerVariables = [];

    /**
     * Invoke the router to load a given resource.
     * @param string $route
     * @throws exceptions\RouteNotAvailableException
     */
    public static function execute($route)
    {
        self::$route = explode('?', $route)[0];        
        $parameters = self::getStaticRouteParameters($route, $routeName);
        if(self::loadResource($parameters, $routeName)) return;
        
        // Fallback on dynamic routes which are generated by callables if
        // static routes fail
        $parameters = self::getDynamicRouteParameters($route, $routeName);
        if(self::loadResource($parameters, $routeName)) return;
        
        // Throw an exception if we're still alive
        throw new exceptions\RouteNotAvailableException(
           self::$route == '' ? 'Default route' : self::$route
        );
    }
    
    private static function getDynamicRouteParameters($route, &$routeName)
    {
        $parameters = [];
        if(empty($routeParameters)) {
            foreach(self::$dynamicRoutes as $dynamicRoute) {
                $parameters = call_user_func(self::$routes[$dynamicRoute]['function'], $route);
                if(!empty($parameters)) break;
            }
        }       
        return $parameters;
    }
    
    private static function getStaticRouteParameters($route, &$routeName)
    {
        $parameters = [];
        
        // Go through predefined routes till a match is found
        foreach(self::$staticRoutes as $routeName) {
            $routeDesription = self::$routes[$routeName];
            $parameters = self::match($route, $routeDesription);
            if(!empty($parameters)) break;
        }
        
        return $parameters;
    }
    
    private static function loadResource($parameters, $routeName)
    {
        foreach(self::$routes[$routeName]['parameters']['default'] as $parameter => $value)
        {
            if($routeName == 'default' && self::$route != '') continue;
            if(!isset($parameters[$parameter]))
                $parameters[$parameter] = $value;
            else if($parameters[$parameter] === '')
                $parameters[$parameter] = $value;
        }
        $parameters += Input::get();
        if(isset($parameters['controller'])) {
            return self::loadController($parameters);
        } 
        return false;
    }
    
    private static function loadController($params = [])
    {
        $controller = $params['controller'];
        $action = $params['action'];
        
        // Try to get the classname based on router parameters
        $controllerClassName = InjectionContainer::singleton(controllers\interfaces\ClassResolverInterface::class)
            ->getControllerClassName($controller);
        
        // Try to resolve the classname 
        $resolvedControllerClass = InjectionContainer::getResolvedClassName($controllerClassName);
        
        if($resolvedControllerClass) {
            // use resolved class name
            $params['controller_path'] = $controller;
            $controllerInstance = InjectionContainer::resolve($controllerClassName);
        } else if(class_exists($controller)) {
            // use controller class
            $controllerInstance = InjectionContainer::resolve($controller);
        } else {
            // failed!
            return false;
        }
        self::$routerVariables += $params;
        $controllerInstance->executeControllerAction($action, $params);            
        return true;
    }
    
    private static function match($route, $description)
    {
        $parameters = [];
        if(preg_match("|{$description['regexp']}|i", $route, $matches)) {           
            
            foreach($matches as $key => $value) {
                if(!is_numeric($key)) {
                    $parameters[$key] = $value;
                }
            }
            
            if(isset($parameters['route'])) {
                $parameters += self::loadResource($parameters['route']);
            }
        }
        return $parameters;
    }

    public static function mapRoute($name, $pattern, $parameters = [])
    {
        if(is_callable($pattern)) {
            // allocate a dynamic route if pattern is callable
            $routeDetails = [
                'name' => $name,
                'function' => $pattern,
                'parameters' => $parameters
            ];
            self::$dynamicRoutes[] = $name;
        } else {
            // generate a PCRE regular expression from pattern
            self::$tempVariables = [];

            $regexp = preg_replace_callback(
                "/{(?<prefix>\*|#)?(?<name>[a-z_][a-zA_Z0-9\_]*)}/", 
                function($matches) {
                    self::$tempVariables[] = $matches['name'];
                    return sprintf(
                        "(?<{$matches['name']}>[a-z0-9_.~:#[\]@!$&'()*+,;=%s]+)?", 
                        $matches['prefix'] ? "\-/_" : null
                    );
                },
                str_replace('/', '(/)?', $pattern)
            );
            
            $routeDetails = [
                'pattern' => $pattern,
                'regexp' => $regexp,
                'parameters' => $parameters,
                'variables' => self::$tempVariables
            ];  
            
            self::$staticRoutes[] = $name;       
        }
        self::$routes[$name] = $routeDetails;
    }

    public static function getVar($var)
    {
        if (isset(self::$routerVariables[$var])) {
            return self::$routerVariables[$var];
        }
        return null;
    }
    
    public static function getRoute()
    {
        return self::$route;
    }
    
    public static function getRouteDefinition($routeName)
    {
        return self::$staticRoutes[$routeName];
    }
}
