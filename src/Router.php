<?php

namespace ntentan;

use ntentan\utils\Input;
use ntentan\panie\InjectionContainer;
use ntentan\panie\exceptions\ResolutionException;

class Router
{
    /**
     * The routing table. An array of regular expressions and associated
     * operations. If a particular request sent in through the URL matches a
     * regular expression in the table, the associated operations are executed.
     *
     * @var array
     */
    private static $routes = [];
    
    private static $dynamicRoutes = [];
    
    /**
     * Keeps track of the order in which routes were added to the routing table.
     * @var type 
     */
    private static $routeOrder = [];
    
    private static $tempVariables = [];

    /**
     * The route which is currently being executed. If the routing engine has
     * modified the requested route, this property would hold the value of the
     * new route.
     * @var string
     */
    private static $route;

    /**
     * Variables exposed through getVar()
     * @var type 
     */
    private static $routerVariables = [];

    /**
     * Invoke the router to load a given resource.
     * @param string $route
     * @throws exceptions\RouteNotAvailableException
     */
    public static function loadResource($route)
    {
        self::$route = $route;
        if($route == '' && isset(self::$route['default']['parameters']['default'])) {
            // Map to the default route if no route is presented
            if(self::loadController([
                'controller' => self::$routes['default']['parameters']['default']['controller'], 
                'action' => self::$routes['default']['parameters']['default']['action']
            ])) return;
        } else { 
            // Go through predefined routes till a match is found
            foreach(self::$routeOrder as $routeName) {
                $routeDesription = self::$routes[$routeName];
                if(self::match($route, $routeDesription)) return;
            }
        }
        // Fallback on dynamic routes which are generated by callables
        foreach(self::$dynamicRoutes as $dynamicRoute) {
            $params = call_user_func($dynamicRoute['function'], $route);
            if(self::loadController($params)) return;
        }
        // Throw an exception if we're still alive
        throw new exceptions\RouteNotAvailableException(
           $route == '' ? 'Default route' : $route
        );
    }
    
    private static function loadController($params = [])
    {
        $controller = $params['controller'];
        $action = $params['action'];
        $controllerClass = InjectionContainer::singleton(controllers\interfaces\ClassResolverInterface::class)
            ->getControllerClassName($controller);
        if($controllerClass = InjectionContainer::getResolvedClassName($controllerClass)) {
            $params['controller_path'] = $controller;
            $controllerInstance = InjectionContainer::resolve($controllerClass);
        } else if(class_exists($controller)) {
            $controllerInstance = InjectionContainer::resolve($controller);
        } else {
            return false;
        }
        self::$routerVariables += $params;
        $controllerInstance->executeControllerAction($action, $params);            
        return true;
    }
    
    private static function match($route, $description)
    {
        if(preg_match("|{$description['regexp']}|i", $route, $matches)) {           
            $parameters = $description['parameters']['default'] + 
                Input::get() + Input::post();
            
            foreach($matches as $key => $value) {
                if(!is_numeric($key)) {
                    $parameters[$key] = $value;
                }
            }
            
            if(isset($parameters['controller'])) {
                return self::loadController($parameters);
            } elseif(isset($parameters['route'])) {
                self::$routerVariables += $parameters;
                self::loadResource($parameters['route']);
                return true;
            }
        }
        return false;
    }

    public static function mapRoute($name, $pattern, $parameters = [])
    {
        // Get a regular expression from the pattern
        if(is_callable($pattern)) {
            self::$dynamicRoutes[$name] = [
                'name' => $name,
                'function' => $pattern
            ];
        } else {
            self::$routeOrder[] = $name;
            self::$tempVariables = [];

            $regexp = preg_replace_callback(
                "/{(?<prefix>\*|#)?(?<name>[a-z_][a-zA_Z0-9\_]*)}/", 
                function($matches) {
                    self::$tempVariables[] = $matches['name'];
                        return sprintf(
                            "(?<{$matches['name']}>[a-z0-9_.~:#[\]@!$&'()*+,;=%s]+)?", 
                            $matches['prefix'] ? "\-/_" : null
                        );
                },
                str_replace('/', '(/)?', $pattern)
            );
            if(isset($parameters['default'])) {
                foreach($parameters['default'] as $parameter => $value) {
                    if(!in_array($parameter, self::$tempVariables)) self::$tempVariables[] = $parameter;
                }
            }

            self::$routes[$name] = [
                'pattern' => $pattern,
                'regexp' => $regexp,
                'parameters' => $parameters,
                'variables' => self::$tempVariables
            ];            
        }
    }

    public static function getVar($var)
    {
        if (isset(self::$routerVariables[$var])) {
            return self::$routerVariables[$var];
        }
        return null;
    }
    
    public static function getRoute()
    {
        return self::$route;
    }
    
    public static function getRouteDefinition($routeName)
    {
        return self::$routes[$routeName];
    }
}
